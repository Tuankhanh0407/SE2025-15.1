version: "3.9"
services:
  db:
    environment:
      POSTGRES_PASSWORD: postgres
    healthcheck:
      test: ["CMD", "pg_isready"]
    image: "postgres:14-alpine"
    user: postgres
    volumes:
      - pgdata:/var/lib/postgresql/data
    ports:
      - "5432:5432"
  mailpit:
    image: axllent/mailpit:v1.20
    ports:
      - "1025:1025"
  mailpit-https:
    image: nginx:1.27-alpine
    depends_on:
      - mailpit
    ports:
      - "8025:8025"
    volumes:
      - ./services/reticulum/priv/dev-ssl.cert:/etc/ssl/certs/hubs.local.pem:ro
      - ./services/reticulum/priv/dev-ssl.key:/etc/ssl/private/hubs.local.key:ro
    command:
      - /bin/sh
      - -lc
      - |
        cat > /usr/share/nginx/html/hubs-inject.js <<'EOF'
        (function(){
          try { console.debug("[hubs-inject] loaded v13", location.href); } catch(e) {}
          function elIn(doc, tag, attrs, text){var d=doc||document; var e=d.createElement(tag); if(attrs){Object.keys(attrs).forEach(function(k){e.setAttribute(k, attrs[k]);});} if(text){e.textContent=text;} return e;}
          function decisionKey(token){ return "hubs-signin-decision:"+(token||""); }
          function getDecision(token){
            try {
              if(!token) return null;
              var v=localStorage.getItem(decisionKey(token));
              return v || null;
            } catch(e) { return null; }
          }
          function setDecision(token, value){
            try {
              if(!token) return;
              localStorage.setItem(decisionKey(token), value);
            } catch(e) {}
          }
          function safeGetIframeDocs(){
            var out=[];
            var iframes=[];
            try { iframes = Array.prototype.slice.call(document.querySelectorAll("iframe")); } catch(e) { iframes=[]; }
            for(var i=0;i<iframes.length;i++){
              try {
                var d=iframes[i].contentDocument;
                if(d && d.documentElement) out.push(d);
              } catch(e) {}
            }
            return out;
          }
          function removeUi(){
            // Remove from main doc and any same-origin iframe docs.
            try {
              var existing=document.getElementById("hubs-accept-deny");
              if(existing) existing.remove();
            } catch(e) {}
            var docs=safeGetIframeDocs();
            for(var i=0;i<docs.length;i++){
              try {
                var existing2=docs[i].getElementById("hubs-accept-deny");
                if(existing2) existing2.remove();
              } catch(e) {}
            }
          }
          function isViewPage(){
            return /^\/view\//.test(location.pathname);
          }
          function parseConfirmLink(msg){
            var candidates=[];
            try {
              if (msg && msg.HTML) candidates.push(msg.HTML);
              if (msg && msg.Text) candidates.push(msg.Text);
            } catch(e) {}
            var re=/https?:\/\/[^"\s<>]+\/confirm-signin\?[^"\s<>]+/g;
            for (var i=0;i<candidates.length;i++){
              var m=candidates[i].match(re);
              if (m && m.length) return m[0];
            }
            return null;
          }
          function parseRawQuery(link){
            // We want the raw (percent-encoded) values from the confirm link.
            // Using URLSearchParams would decode and re-encode, which can be fragile for base64 payloads.
            try {
              var q=(link.split("?")[1]||"");
              var out={};
              q.split("&").forEach(function(kv){
                if(!kv) return;
                var idx=kv.indexOf("=");
                var k=idx===-1 ? kv : kv.slice(0, idx);
                var v=idx===-1 ? "" : kv.slice(idx+1);
                out[k]=v;
              });
              return out;
            } catch(e) {
              return {};
            }
          }
          function postForm(url, data){
            // `data` values are assumed to be raw percent-encoded already.
            var body=Object.keys(data).map(function(k){return k+"="+(data[k]||"");}).join("&");
            return fetch(url, {method:"POST", headers:{"Content-Type":"application/x-www-form-urlencoded"}, body:body});
          }
          function createActionBar(doc){
            var d=doc || document;
            var wrap=elIn(d,"div", {id:"hubs-accept-deny",style:"margin-top:12px;padding:12px;border:1px solid #e5e7eb;border-radius:12px;background:#ffffff;box-shadow:0 10px 25px rgba(0,0,0,.08);display:flex;gap:10px;align-items:center;margin-bottom:16px;"});
            var title=elIn(d,"div", {style:"font-weight:600;"}, "Sign-In Request");
            var status=elIn(d,"div", {style:"margin-left:auto;font-size:12px;color:#64748b;white-space:nowrap;"}, "Loading...");
            var acceptBtn=elIn(d,"button", {type:"button", style:"padding:8px 12px;border-radius:10px;border:0;background:#22c55e;color:#052e16;font-weight:700;cursor:pointer;"}, "Accept");
            var denyBtn=elIn(d,"button", {type:"button", style:"padding:8px 12px;border-radius:10px;border:0;background:#ef4444;color:#450a0a;font-weight:700;cursor:pointer;"}, "Deny");
            acceptBtn.disabled=true; denyBtn.disabled=true;
            wrap.appendChild(title);
            wrap.appendChild(acceptBtn);
            wrap.appendChild(denyBtn);
            wrap.appendChild(status);
            return {wrap, status, acceptBtn, denyBtn};
          }
          var actionBar=null;
          var messagePayload={currentId:null, fetchInFlight:false};
          function findTargetNodeIn(doc){
            var d=doc || document;
            var main=null;
            try { main=d.querySelector("#app") || d.querySelector("main") || d.body; } catch(e) { main=null; }
            if(!main) return null;
            var targetNeedle="if you did not make this request";
            var ps=[];
            try { ps=main.querySelectorAll("p"); } catch(e) { ps=[]; }
            for(var i=0;i<ps.length;i++){
              var t=(ps[i].textContent||"").trim().toLowerCase();
              if(!t || t.indexOf(targetNeedle)===-1) continue;
              try { if(ps[i].getClientRects && ps[i].getClientRects().length===0) continue; } catch(e) {}
              return ps[i];
            }
            return null;
          }
          function findTargetNode(){
            // 1) Try main doc
            var mainAnchor=findTargetNodeIn(document);
            if(mainAnchor) return {anchor: mainAnchor, doc: document};
            // 2) Try same-origin iframe docs
            var docs=safeGetIframeDocs();
            for(var i=0;i<docs.length;i++){
              var a=findTargetNodeIn(docs[i]);
              if(a) return {anchor:a, doc:docs[i]};
            }
            return null;
          }
          function finalizeState(message){
            actionBar.status.textContent=message;
            actionBar.acceptBtn.style.display="none";
            actionBar.denyBtn.style.display="none";
            setTimeout(function(){ removeUi(); }, 1200);
          }

          function ensureMessageData(id){
            if(!actionBar) return;
            if(messagePayload.currentId===id || messagePayload.fetchInFlight) return;
            messagePayload.currentId=id;
            messagePayload.fetchInFlight=true;
            actionBar.status.textContent="Loading...";
            actionBar.acceptBtn.disabled=true;
            actionBar.denyBtn.disabled=true;
            actionBar.acceptBtn.onclick=actionBar.denyBtn.onclick=null;
            fetch("/api/v1/message/"+encodeURIComponent(id)).then(function(r){
              try { console.debug("[hubs-inject] message fetch", id, r.status); } catch(e) {}
              return r.json();
            }).then(function(msg){
              var link=parseConfirmLink(msg);
              if(!link){actionBar.status.textContent="No sign-in request found."; return;}
              var qp=parseRawQuery(link);
              var auth_topic=qp["auth_topic"]; 
              var auth_token=qp["auth_token"]; 
              var auth_payload=qp["auth_payload"]; 
              if(!auth_topic||!auth_token||!auth_payload){actionBar.status.textContent="Missing auth params."; return;}

              var prior=getDecision(auth_token);
              if(prior==="accepted"){
                finalizeState("Accepted");
                return;
              }
              if(prior==="denied"){
                finalizeState("Denied");
                return;
              }

              actionBar.status.textContent="Ready";
              actionBar.acceptBtn.disabled=false;
              actionBar.denyBtn.disabled=false;
              actionBar.acceptBtn.onclick=function(){
                actionBar.acceptBtn.disabled=true; actionBar.denyBtn.disabled=true; actionBar.status.textContent="Accepting...";
                postForm("/confirm-signin/accept",{auth_topic:auth_topic,auth_token:auth_token,auth_payload:auth_payload})
                  .then(function(r){
                    if(r.ok || r.status===400){
                      setDecision(auth_token, "accepted");
                      finalizeState("Accepted");
                    } else {
                      actionBar.status.textContent="Failed ("+r.status+")";
                    }
                  })
                  .catch(function(){actionBar.status.textContent="Failed";});
              };
              actionBar.denyBtn.onclick=function(){
                actionBar.acceptBtn.disabled=true; actionBar.denyBtn.disabled=true; actionBar.status.textContent="Denying...";
                postForm("/confirm-signin/deny",{auth_token:auth_token})
                  .then(function(r){
                    if(r.ok || r.status===400){
                      setDecision(auth_token, "denied");
                      finalizeState("Denied");
                    } else {
                      actionBar.status.textContent="Failed ("+r.status+")";
                    }
                  })
                  .catch(function(){actionBar.status.textContent="Failed";});
              };
            }).catch(function(){actionBar.status.textContent="Failed to load message.";})
              .finally(function(){messagePayload.fetchInFlight=false;});
          }
          var currentAnchor=null;
          var currentDoc=null;
          function placeActionBar(anchor){
            if(!anchor){ removeUi(); currentAnchor=null; return; }
            var doc=anchor.ownerDocument || document;
            if(!actionBar || currentDoc!==doc){
              removeUi();
              actionBar=createActionBar(doc);
              currentDoc=doc;
              currentAnchor=null;
            }
            if(currentAnchor!==anchor){
              removeUi();
              anchor.parentNode.insertBefore(actionBar.wrap, anchor.nextSibling);
              currentAnchor=anchor;
            }
            actionBar.wrap.style.display="flex";
          }
          function mount(){
            if(!isViewPage()){ removeUi(); messagePayload.currentId=null; currentAnchor=null; return; }
            var id=location.pathname.split("/")[2];
            if(!id) return;
            var found=findTargetNode();
            if(found && found.anchor){
              placeActionBar(found.anchor);
              ensureMessageData(id);
            } else {
              try { console.debug("[hubs-inject] anchor not found yet"); } catch(e) {}
              removeUi();
              messagePayload.currentId=null;
              messagePayload.fetchInFlight=false;
            }
          }
          function tick(){ try{ mount(); } catch(e){} }
          if(document.readyState==="loading") document.addEventListener("DOMContentLoaded", tick);
          else tick();
          setInterval(tick, 750);
        })();
        EOF

        cat > /etc/nginx/conf.d/default.conf <<'EOF'
        map $$http_upgrade $$connection_upgrade {
          default upgrade;
          '' close;
        }

        server {
          listen 8025;
          server_name hubs.local;

          location ^~ /confirm-signin/ {
            proxy_pass https://reticulum:4000;
            proxy_ssl_verify off;
            proxy_buffer_size 64k;
            proxy_buffers 16 64k;
            proxy_busy_buffers_size 128k;
            proxy_set_header Host $$host;
            proxy_set_header X-Forwarded-Proto http;
            proxy_set_header X-Forwarded-For $$proxy_add_x_forwarded_for;
          }

          location = /confirm-signin {
            proxy_pass https://reticulum:4000;
            proxy_ssl_verify off;
            proxy_buffer_size 64k;
            proxy_buffers 16 64k;
            proxy_busy_buffers_size 128k;
            proxy_set_header Host $$host;
            proxy_set_header X-Forwarded-Proto http;
            proxy_set_header X-Forwarded-For $$proxy_add_x_forwarded_for;
          }

          # Mailpit uses websocket for live updates.
          location = /api/events {
            proxy_pass http://mailpit:8025;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $$http_upgrade;
            proxy_set_header Connection $$connection_upgrade;
            proxy_set_header Host $$host;
            proxy_set_header X-Forwarded-Proto http;
            proxy_set_header X-Forwarded-For $$proxy_add_x_forwarded_for;
          }

          location = /hubs-inject.js {
            default_type application/javascript;
            root /usr/share/nginx/html;
            add_header Cache-Control "no-store";
          }

          location / {
            proxy_pass http://mailpit:8025;
            proxy_set_header Host $$host;
            proxy_set_header X-Forwarded-Proto http;
            proxy_set_header X-Forwarded-For $$proxy_add_x_forwarded_for;
            proxy_set_header Accept-Encoding "";
            proxy_hide_header Content-Security-Policy;

            sub_filter_once on;
            sub_filter_types text/html;
            sub_filter '</body>' '<script src="/hubs-inject.js?v=13"></script></body>';
            sub_filter '</BODY>' '<script src="/hubs-inject.js?v=13"></script></BODY>';
          }
        }
        EOF
        nginx -g 'daemon off;'
  dialog:
    build:
      context: .
      dockerfile: dockerfiles/dialog.Dockerfile
    environment:
      AUTH_KEY: /etc/perms.pub.pem
      HTTPS_CERT_FULLCHAIN: /etc/ssl/fullchain.pem
      HTTPS_CERT_PRIVKEY: /etc/ssl/privkey.pem
      INTERACTIVE: "false"
      MEDIASOUP_MIN_PORT: 41000
      MEDIASOUP_MAX_PORT: 41050
      MEDIASOUP_ANNOUNCED_IP: ${PRIVATE_NETWORK_IP}
    ports:
      - "4443:4443"
      # This should be the same as MEDIASOUP_MIN_PORT and MEDIASOUP_MAX_PORT
      # You might neeed to increase this number depending on how many clients you are connecting.
      # (Keep the ports range small to improve container startup time)
      - "41000-41050:41000-41050"
      - "41000-41050:41000-41050/udp"
    volumes:
      - dialog:/code
    working_dir: /code
  hubs-admin:
    build:
      context: .
      dockerfile: dockerfiles/hubs.Dockerfile
    command: npm run local
    environment:
      INTERNAL_HOSTNAME: hubs-admin
    healthcheck:
      test: ["CMD", "curl", "-fk", "https://localhost:8989/admin.html"]
    platform: linux/amd64
    ports:
      - "8989:8989"
    volumes:
      - hubs:/code
    working_dir: /code/admin
  hubs-client:
    build:
      context: .
      dockerfile: dockerfiles/hubs.Dockerfile
    command: npm run local
    environment:
      INTERNAL_HOSTNAME: hubs-client
    healthcheck:
      start_period: 3m30s
      test: ["CMD", "curl", "-fk", "https://localhost:8080"]
    platform: linux/amd64
    ports:
      - "8080:8080"
    volumes:
      - hubs:/code
    working_dir: /code
  hubs-storybook:
    build:
      context: .
      dockerfile: dockerfiles/hubs.Dockerfile
    command: npm run storybook
    healthcheck:
      test: ["CMD", "curl", "-fk", "http://hubs.local:6006"]
    platform: linux/amd64
    ports:
      - "6006:6006"
    volumes:
      - hubs:/code
    working_dir: /code
  postgrest:
    build:
      context: .
      dockerfile: dockerfiles/postgrest.Dockerfile
  reticulum:
    build:
      context: ./services/reticulum
      dockerfile: TurkeyDockerfile
      target: dev
    depends_on:
      - db
    healthcheck:
      test: ["CMD-SHELL", "wget -q --no-check-certificate --spider https://127.0.0.1:4000/stream-offline.png"]
      interval: 10s
      timeout: 5s
      retries: 30
      start_period: 60s
    environment:
      DB_CREDENTIALS: postgres
      DB_HOST: db
      DIALOG_HOSTNAME: "hubs.local"
      DIALOG_PORT: 4443
      HUBS_ADMIN_INTERNAL_HOSTNAME: hubs-admin
      HUBS_CLIENT_INTERNAL_HOSTNAME: hubs-client
      POSTGREST_INTERNAL_HOSTNAME: postgrest
      SPOKE_INTERNAL_HOSTNAME: spoke
      SMTP_HOST: mailpit
      SMTP_PORT: 1025
    ports:
      - "4000:4000"
    volumes:
      - reticulum:/code
      - retstorage:/code/storage/dev
  spoke:
    build:
      context: .
      dockerfile: dockerfiles/spoke.Dockerfile
    environment:
      CORS_PROXY_SERVER: "hubs-proxy.local:4000"
      INTERNAL_HOSTNAME: spoke
    platform: linux/amd64
    ports:
      - "9090:9090"
    volumes:
      - spoke:/code
networks:
  default:
    name: mozilla-hubs
volumes:
  dialog:
  hubs:
  pgdata:
  reticulum:
  retstorage:
  spoke:
x-mutagen:
  sync:
    defaults:
      ignore:
        paths:
          - ".DS_Store"
          - ".gitignore"
          - "/certs/"
          - "/node_modules/"
          - "package-lock.sha512"
        vcs: true
      mode: "two-way-resolved"
    dialog:
      alpha: ./services/dialog
      beta: "volume://dialog"
    hubs:
      alpha: ./services/hubs
      beta: "volume://hubs"
      ignore:
        paths:
          - "/admin/certs/"
          - "/admin/node_modules/"
    reticulum:
      alpha: ./services/reticulum
      beta: "volume://reticulum"
      ignore:
        paths:
          - "/_build/"
          - "/bin/"
          - "/storage/"
    spoke:
      alpha: ./services/spoke
      beta: "volume://spoke"
